# Mapserver in Rust

This is an experimental Rust implementation of [UMN Mapserver](https://mapserver.gis.umn.edu/).

Mapserver is a C library and suite of executables
(`libmapserver` and `mapserver-bin` respectively on Debian)
that take a variety of common GIS data sources as input
and render images for use in web-mapping applications.

What is a map image, according to UNM Mapserver?

- a collection of layers, consisting roughly of data sources plus their styling parameters.
- a geographic extent.
- an output format (size and other parameters).

The [mapfile](https://www.mapserver.org/mapfile/) is the primary mechansim for configuring Mapserver, a domain-specific language
for rendering geospatial data into map images.

## C library quirks

Mapserver leans heavily on GDAL for file format support and this has some implications.
Specifically, the `GDALOpenShared` call will indeed open a shared dataset across threads,
but at a cost. Each OS thread that opens a shared dataset will get a complete clone of the dataset.
Not ideal, as each clone will have its own memory footprint, its own cache, its own lifecycle, etc.

GDAL Datasets are stateful (importantly, they cache expensive data reads) and take a long time to spin up.
This lead to the paradoxical situation where increasing CPU resources (more threads)
will increase the number of open datasets, thus _increasing_ memory footprint but _reducing_ cache hits, ultimately hurting performance.

TLDR: Embrace the single-threadedness of Mapserver and GDAL. Each map living on it's own isolated thread
will give us a long-running GDAL dataset to fully leverage its internal caching and thread-local state.

## Rust API with bindgen

Autogenerated C bindings to libmapserver, providing low-level FFI. See the [`mapserver-sys`](./mapserver-sys) directory.

Inspired by https://www.youtube.com/watch?v=pePqWoTnSmQ

## Opinionated Rust web server

See the [`mapserver-rs`] directory.

- **Embrace the mapfile**, make it the primary interface. No need to reimplement
  the rendering logic in Rust! Usage of libmapserver will be high-level and the
  mapfile DSL will handle all the detailed configuration.

- **Embrace the threadpool**. Because of Mapserver and GDAL's tendency towards single-threaded data structures,
  let's just avoid trouble and run every "Mapfile" on a dedicated thread.

- **Embrace an async Rust web framework**. Axum seems to work nicely.
  Mapserver `MAP` objects are effectively single-threaded and thus require thread-level management.
  But HTTP requests are well-suited to asyncronous runtimes like tokio.

- **Embrace manual garbage collection**. Each MapPool has a configurable idle timeout,
  to clean up memory from map threads that are no longer in use.

## Mixing threadpools and async via channels

Wait. An async rust http framework communicating to threads via channels?
How do we bridge the gap between async tasks on the tokio runtime and the thread-local state?

A pair of zero-bounded `crossbeam` channels effectively gives us a request-response interface
between async tasks and dedicated map threads. This allows us to send queries to the appropriate map thread
and receive images back on the async http tasks (which also live in a different threadpool managed by tokio, an implementation detail).

## Personal note

The University of Minnesota's Mapserver project was the first open source project that I used regularly.
As a graduate student in 2001, there were proprietary map servers available but they were expensive and slow.
One project had attempted to build a web map based on ArcIMS and utterly failed, spending 90% of its budget
without much to show for it. With the remaining 10% budget, we installed Mapserver on a Solaris Unix system,
wrote mapfiles for our datasets, and built a basic HTML interface. It was no Google Maps (which did not exist yet)
but it worked! This kicked off my lifelong love of open source and introduced me to the wonderful community of
open source geo practitioners that has grown to become the OSGeo/Foss4G ecosystem.
